This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-11T02:10:56.186Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
database/
  code_repository.py
  connection.py
  context.py
  test_repository.py
embedding/
  api_client.py
  gemini_client.py
  similarity.py
.gitignore
check_dataset.py
db_utils.py
main.py
question.txt
sample_codes.py
verify_data.py

================================================================
Files
================================================================

================
File: database/code_repository.py
================
import json
from typing import List, Optional, Tuple
from .context import db_context


def insert_code(code: str) -> Optional[int]:
    """コードをデータベースに挿入します。"""
    try:
        with db_context() as (_, cursor):
            # 既存のコードをチェック
            cursor.execute("SELECT id FROM codes WHERE code = ?", (code,))
            existing_code = cursor.fetchone()
            if existing_code:
                print(f"Code already exists with ID: {existing_code[0]}")
                return existing_code[0]

            # 新しいコードを挿入
            cursor.execute(
                """
                INSERT INTO codes (code, embedding)
                VALUES (?, ?)
            """,
                (code, None),
            )
            return cursor.lastrowid
    except Exception as e:
        print(f"Error inserting code data: {e}")
        return None


def update_embedding(code_id: int, embedding: list) -> bool:
    """コードの埋め込みベクトルを更新します。"""
    try:
        with db_context() as (_, cursor):
            embedding_json = json.dumps(embedding)
            cursor.execute(
                "UPDATE codes SET embedding = ? WHERE id = ?",
                (embedding_json, code_id),
            )
            return True
    except Exception as e:
        print(f"Error updating code embedding: {e}")
        return False


def get_embeddings() -> List[Tuple[int, list]]:
    """全てのコード埋め込みベクトルを取得します。"""
    try:
        with db_context() as (_, cursor):
            cursor.execute("SELECT id, embedding FROM codes WHERE embedding IS NOT NULL")
            code_embeddings = []
            for code_id, embedding_json in cursor:
                try:
                    embedding = json.loads(embedding_json)
                    code_embeddings.append((code_id, embedding))
                except json.JSONDecodeError as e:
                    print(f"Error decoding embedding for code ID {code_id}: {e}")
                    continue
            return code_embeddings
    except Exception as e:
        print(f"Error getting embeddings: {e}")
        return []


def get_code_by_id(code_id: int) -> Optional[str]:
    """指定されたIDのコードを取得します。"""
    try:
        with db_context() as (_, cursor):
            cursor.execute("SELECT code FROM codes WHERE id = ?", (code_id,))
            result = cursor.fetchone()
            return result[0] if result else None
    except Exception as e:
        print(f"Error getting code by ID: {e}")
        return None

================
File: database/connection.py
================
import sqlite3

DATABASE_NAME = "code_comparison.db"


def get_connection():
    """データベース接続を取得します。"""
    return sqlite3.connect(DATABASE_NAME)


def create_database():
    """データベースとテーブルを初期化します。"""
    conn = get_connection()
    cursor = conn.cursor()

    cursor.execute(
        """
        CREATE TABLE IF NOT EXISTS codes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            code TEXT NOT NULL UNIQUE,
            embedding TEXT
        )
    """
    )

    cursor.execute(
        """
        CREATE TABLE IF NOT EXISTS test_cases (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            code_id INTEGER,
            input TEXT NOT NULL,
            expected_output TEXT NOT NULL,
            FOREIGN KEY (code_id) REFERENCES codes(id)
        )
    """
    )

    conn.commit()
    conn.close()

================
File: database/context.py
================
from contextlib import contextmanager
from typing import Generator, Tuple
import sqlite3
from .connection import get_connection

@contextmanager
def db_context() -> Generator[Tuple[sqlite3.Connection, sqlite3.Cursor], None, None]:
    """データベース操作のためのコンテキストマネージャ。
    
    接続の取得、カーソルの作成、コミット/ロールバック、クローズを自動的に処理します。
    
    Yields:
        Tuple[sqlite3.Connection, sqlite3.Cursor]: データベース接続とカーソルのタプル
    """
    conn = get_connection()
    cursor = conn.cursor()
    try:
        yield conn, cursor
        conn.commit()
    except Exception as e:
        conn.rollback()
        raise e
    finally:
        conn.close()

================
File: database/test_repository.py
================
from typing import List, Tuple, Optional
from .context import db_context


def insert_test_case(code_id: int, input_val: str, expected_output: str) -> bool:
    """テストケースをデータベースに挿入します。
    
    同じコードに対して同じ入力と期待される出力の組み合わせが既に存在する場合は、
    重複を避けるために挿入を行いません。

    Args:
        code_id: テストケースが関連付けられるコードのID
        input_val: テストケースの入力値
        expected_output: テストケースの期待される出力

    Returns:
        bool: 挿入が成功した場合、または同じテストケースが既に存在する場合はTrue
    """
    try:
        with db_context() as (_, cursor):
            # 既存のテストケースをチェック
            cursor.execute(
                """
                SELECT id FROM test_cases
                WHERE code_id = ? AND input = ? AND expected_output = ?
                """,
                (code_id, input_val, expected_output),
            )
            existing_test = cursor.fetchone()
            if existing_test:
                print(f"Test case already exists with ID: {existing_test[0]}")
                return True

            # 新しいテストケースを挿入
            cursor.execute(
                """
                INSERT INTO test_cases (code_id, input, expected_output)
                VALUES (?, ?, ?)
                """,
                (code_id, input_val, expected_output),
            )
            return True
    except Exception as e:
        print(f"Error inserting test case data: {e}")
        return False


def get_test_cases(code_id: int) -> List[Tuple[str, str]]:
    """指定されたコードIDのテストケースを取得します。

    Args:
        code_id: テストケースを取得するコードのID

    Returns:
        List[Tuple[str, str]]: (入力, 期待される出力)のタプルのリスト
    """
    try:
        with db_context() as (_, cursor):
            cursor.execute(
                "SELECT input, expected_output FROM test_cases WHERE code_id = ?",
                (code_id,)
            )
            return cursor.fetchall()
    except Exception as e:
        print(f"Error getting test cases: {e}")
        return []


def get_test_case_count(code_id: int) -> int:
    """指定されたコードIDのテストケース数を取得します。

    Args:
        code_id: テストケース数を取得するコードのID

    Returns:
        int: テストケースの数
    """
    try:
        with db_context() as (_, cursor):
            cursor.execute(
                "SELECT COUNT(*) FROM test_cases WHERE code_id = ?",
                (code_id,)
            )
            return cursor.fetchone()[0]
    except Exception as e:
        print(f"Error getting test case count: {e}")
        return 0

================
File: embedding/api_client.py
================
import boto3
import json


class BedrockClient:
    def __init__(self):
        self.client = boto3.client(
            service_name="bedrock-runtime",
            region_name="ap-northeast-1"  # Tokyo region
        )

    def get_embedding(self, text: str):
        """テキストの埋め込みベクトルを取得します。"""
        model_id = "amazon.titan-embed-text-v1"
        body = json.dumps({"inputText": text})
        accept = "application/json"
        content_type = "application/json"

        response = self.client.invoke_model(
            body=body, modelId=model_id, accept=accept, contentType=content_type
        )
        response_body = json.loads(response.get("body").read())
        embedding = response_body.get("embedding")
        return embedding

================
File: embedding/gemini_client.py
================
import google.generativeai as genai
import os
from dotenv import load_dotenv

load_dotenv()


class GeminiClient:
    def __init__(self):
        api_key = os.getenv("GEMINI_API_KEY")
        if not api_key:
            raise ValueError("GEMINI_API_KEY environment variable not set")
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel("gemini-pro")

    def generate_code(self, prompt: str) -> str:
        """Geminiを使用してコードを生成します。

        Args:
            prompt: コード生成のためのプロンプト

        Returns:
            生成されたコード
        """
        try:
            response = self.model.generate_content(
                f"{prompt}。Pythonの関数コードのみを記述してください。他の説明や装飾は一切不要です。"
            )
            # 不要な部分（```python や ```）を取り除く
            code = response.text.strip()
            if code.startswith("```python"):
                code = code[len("```python") :].strip()
            if code.endswith("```"):
                code = code[: -len("```")].strip()
            return code
        except Exception as e:
            print(f"Error generating code with Gemini: {e}")
            return None

================
File: embedding/similarity.py
================
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity


def find_most_similar(target_embedding: list, code_embeddings: list):
    """最も類似したコードを見つけます。

    Args:
        target_embedding: 検索対象の埋め込みベクトル
        code_embeddings: (コードID, 埋め込みベクトル)のタプルのリスト

    Returns:
        (最も類似したコードのID, 類似度)のタプル
    """
    if not code_embeddings:
        return None, 0

    best_match_id = None
    best_similarity = -1

    target_embedding = np.array(target_embedding).reshape(1, -1)

    for code_id, embedding in code_embeddings:
        embedding = np.array(embedding).reshape(1, -1)
        similarity = cosine_similarity(target_embedding, embedding)[0][0]

        if similarity > best_similarity:
            best_similarity = similarity
            best_match_id = code_id

    return best_match_id, best_similarity

================
File: .gitignore
================
__pycache__
code_comparison.db
.env
APPS
cline_docs

================
File: check_dataset.py
================
from datasets import load_dataset

def check_dataset_structure():
    print("Loading dataset...")
    dataset = load_dataset("evalplus/mbppplus")
    
    print("\nDataset structure:")
    print(dataset)
    
    print("\nFirst example details:")
    first_example = dataset["test"][0]
    for key, value in first_example.items():
        print(f"\n{key}:")
        if isinstance(value, list):
            print(f"Type: {type(value)}")
            print(f"Length: {len(value)}")
            print("First few items:")
            for item in value[:3]:
                print(f"  {item}")
        else:
            print(f"Type: {type(value)}")
            print(f"Value: {value}")

if __name__ == "__main__":
    check_dataset_structure()

================
File: db_utils.py
================
import json
import re
from typing import Dict, List, Any, Optional, Tuple
from database.code_repository import insert_code, update_embedding
from database.test_repository import insert_test_case
from embedding.api_client import BedrockClient
from datasets import load_dataset
from database.connection import create_database
import ast


def convert_complex_number(num: complex) -> Dict[str, float]:
    """複素数をJSON シリアライズ可能な形式に変換します。

    Args:
        num: 変換する複素数

    Returns:
        Dict[str, float]: 実部と虚部を含む辞書
    """
    return {
        "real": num.real,
        "imag": num.imag
    }


def convert_to_json_serializable(obj: Any) -> Any:
    """オブジェクトをJSON シリアライズ可能な形式に変換します。

    Args:
        obj: 変換する対象のオブジェクト

    Returns:
        Any: JSON シリアライズ可能な形式に変換されたオブジェクト
    """
    if isinstance(obj, (set, frozenset)):
        return list(obj)
    elif isinstance(obj, complex):
        return convert_complex_number(obj)
    elif isinstance(obj, tuple):
        return list(obj)
    elif isinstance(obj, dict):
        return {str(k): convert_to_json_serializable(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [convert_to_json_serializable(x) for x in obj]
    elif isinstance(obj, float) and (obj == float('inf') or obj == float('-inf') or obj != obj):  # inf, -inf, nan
        return str(obj)
    return obj


def extract_test_data_from_test_field(test_str: str) -> List[Tuple[Any, Any]]:
    """テストフィールドからテストデータを抽出します。

    Args:
        test_str: テストコードを含む文字列

    Returns:
        List[Tuple[Any, Any]]: (入力値, 期待される出力値)のタプルのリスト
    """
    try:
        # inputsとresultsの部分を抽出
        inputs_match = re.search(r'inputs\s*=\s*(\[.*?\])\s*results', test_str, re.DOTALL)
        results_match = re.search(r'results\s*=\s*(\[.*?\])\s*for', test_str, re.DOTALL)
        
        if not inputs_match or not results_match:
            return []
        
        # 文字列を評価可能な形式に整形
        inputs_str = inputs_match.group(1).replace('\n', '').replace(' ', '')
        results_str = results_match.group(1).replace('\n', '').replace(' ', '')
        
        # 文字列をPythonオブジェクトに変換
        inputs = ast.literal_eval(inputs_str)
        results = ast.literal_eval(results_str)
        
        # 入力と出力のペアを作成し、JSON シリアライズ可能な形式に変換
        test_cases = []
        for input_val, expected in zip(inputs, results):
            input_val = convert_to_json_serializable(input_val)
            expected = convert_to_json_serializable(expected)
            test_cases.append((input_val, expected))
        
        return test_cases
    except Exception as e:
        print(f"Error extracting test data: {e}")
        return []


def process_code(code: str, bedrock_client: BedrockClient) -> int:
    """コードを処理し、データベースに保存します。

    Args:
        code: 保存するコード
        bedrock_client: BedrockClientのインスタンス

    Returns:
        int: 保存されたコードのID、失敗した場合は0
    """
    try:
        code_id = insert_code(code)
        if not code_id:
            return 0

        embedding = bedrock_client.get_embedding(code)
        if not embedding or not update_embedding(code_id, embedding):
            print(f"Failed to update embedding for code ID: {code_id}")
            return 0

        return code_id
    except Exception as e:
        print(f"Error processing code: {e}")
        return 0


def process_test_cases(code_id: int, test_data: List[Tuple[Any, Any]]) -> bool:
    """テストケースを処理し、データベースに保存します。

    Args:
        code_id: 関連するコードのID
        test_data: (入力値, 期待される出力値)のタプルのリスト

    Returns:
        bool: 全てのテストケースの保存が成功した場合はTrue
    """
    try:
        success = True
        for input_val, output_val in test_data:
            try:
                input_str = json.dumps(input_val)
                output_str = json.dumps(output_val)
                
                if not insert_test_case(code_id, input_str, output_str):
                    print(f"Failed to insert test case for code {code_id}")
                    success = False
            except TypeError as e:
                print(f"Error serializing test case: {e}")
                print(f"Input: {type(input_val)}, Output: {type(output_val)}")
                success = False
                
        return success
    except Exception as e:
        print(f"Error processing test cases: {e}")
        return False


def load_and_store_data() -> Dict[str, int]:
    """HuggingFaceのデータセットからデータを読み込み、データベースに格納します。

    Returns:
        Dict[str, int]: 処理結果の統計情報
    """
    stats = {
        "total_solutions": 0,
        "successful_solutions": 0,
        "failed_solutions": 0,
        "successful_test_cases": 0,
    }

    try:
        # データベースの初期化
        print("Initializing database...")
        create_database()

        # データセットの読み込み
        print("Loading dataset...")
        dataset = load_dataset("evalplus/mbppplus")
        print(f"Dataset structure: {dataset}")
        
        if not dataset or "test" not in dataset:
            print("Failed to load dataset or 'test' split not found")
            return stats

        # データセットの最初の要素を表示（デバッグ用）
        first_example = dataset["test"][0]
        print("\nFirst example structure:")
        for key, value in first_example.items():
            print(f"{key}: {type(value)}")
            if key in ["code", "test"]:
                print(f"Sample {key}:", value[:200] + "..." if isinstance(value, str) else value[:2])

        # BedrockClientのインスタンスを作成
        bedrock_client = BedrockClient()

        # 統計情報の初期化
        test_dataset = dataset["test"]
        stats["total_solutions"] = len(test_dataset)
        print(f"\nProcessing {stats['total_solutions']} examples...")

        # 各サンプルの処理
        for i, sample in enumerate(test_dataset):
            if i % 10 == 0:  # より頻繁に進捗を表示
                print(f"Processing example {i}/{stats['total_solutions']}")
                
            code = sample["code"]
            test_data = extract_test_data_from_test_field(sample["test"])

            if not test_data:
                print(f"Failed to extract test data for example {i}")
                stats["failed_solutions"] += 1
                continue

            code_id = process_code(code, bedrock_client)
            if code_id:
                stats["successful_solutions"] += 1
                if process_test_cases(code_id, test_data):
                    stats["successful_test_cases"] += 1
            else:
                stats["failed_solutions"] += 1

        return stats
    except Exception as e:
        print(f"Error loading dataset: {e}")
        import traceback
        traceback.print_exc()
        return stats


if __name__ == "__main__":
    print("=== データ読み込みと保存の開始 ===")
    stats = load_and_store_data()

    print("\n=== 処理結果 ===")
    print(f"総ソリューション数: {stats['total_solutions']}")
    print(f"成功したソリューション: {stats['successful_solutions']}")
    print(f"失敗したソリューション: {stats['failed_solutions']}")
    print(f"テストケース保存成功: {stats['successful_test_cases']}")

================
File: main.py
================
from typing import Dict, List, Optional, Tuple
from database import connection
from database.code_repository import (
    insert_code,
    update_embedding,
    get_code_by_id,
    get_embeddings,
)
from database.test_repository import insert_test_case, get_test_cases
from embedding.api_client import BedrockClient
from embedding.gemini_client import GeminiClient
from embedding.similarity import find_most_similar

# from sample_codes import code_samples


class CodeProcessor:
    def __init__(self):
        self.bedrock_client = BedrockClient()
        self.gemini_client = GeminiClient()

    def process_sample_code(self, code_data: Dict) -> Optional[int]:
        """サンプルコードとそのテストケースを処理します。"""
        code_id = insert_code(code=code_data["code"])
        if not code_id:
            return None

        try:
            embedding = self.bedrock_client.get_embedding(code_data["code"])
            if update_embedding(code_id, embedding):
                print(f"Updated embedding for code ID: {code_id}")

                for test_case in code_data["test_cases"]:
                    if insert_test_case(
                        code_id=code_id,
                        input_val=test_case["input"],
                        expected_output=test_case["expected_output"],
                    ):
                        print(f"Inserted test case for code ID {code_id}")
                return code_id
        except Exception as e:
            print(f"Error processing sample code: {e}")
        return None


class TestRunner:
    @staticmethod
    def run_test_case(
        code: str, input_val: str, expected_output: str
    ) -> Tuple[bool, str]:
        """テストケースを実行します。"""
        try:
            # コードをグローバル名前空間で実行
            namespace = {}
            exec(code, namespace)

            # 関数名を取得（最初の関数定義を使用）
            func_name = next(
                (
                    name
                    for name, obj in namespace.items()
                    if callable(obj) and name != "__builtins__"
                ),
                None,
            )
            if not func_name:
                return False, "No function found in code"

            # 入力値を引数リストに変換
            args = []
            if "," in input_val:
                # カンマで区切られた複数の引数を分割
                for arg in (arg.strip() for arg in input_val.split(",")):
                    try:
                        args.append(eval(arg))
                    except:
                        args.append(arg)
            else:
                try:
                    args.append(eval(input_val))
                except:
                    args.append(input_val)

            # 期待される出力を評価
            try:
                expected = eval(expected_output)
            except:
                expected = expected_output

            # 関数を実行
            actual = namespace[func_name](*args)
            success = actual == expected
            return success, str(actual)

        except Exception as e:
            return False, f"Error: {str(e)}"


class TestResultFormatter:
    @staticmethod
    def format_test_results(test_results: List[Tuple[str, str, bool, str]]) -> str:
        """テスト結果を整形します。"""
        total_tests = len(test_results)
        passed_tests = sum(1 for _, _, success, _ in test_results if success)
        pass_rate = (passed_tests / total_tests * 100) if total_tests > 0 else 0

        output = ["\n=== テスト実行結果 ==="]
        for input_val, expected, success, actual in test_results:
            output.extend(
                [
                    f"\nInput: {input_val}",
                    f"Expected Output: {expected}",
                    f"Actual Output: {actual}",
                    f"Result: {'✓ Pass' if success else '✗ Fail'}",
                ]
            )

        output.extend(
            [
                f"\n=== テスト結果サマリー ===",
                f"テスト成功: {passed_tests}/{total_tests}",
                f"成功率: {pass_rate:.1f}%",
            ]
        )

        return "\n".join(output)


def find_and_test_similar_code(code: str, test_runner: TestRunner) -> None:
    """類似コードを検索し、テストを実行します。"""
    bedrock = BedrockClient()
    code_embedding = bedrock.get_embedding(code)
    code_embeddings = get_embeddings()

    if not code_embeddings:
        print("\nコードデータが見つかりません")
        return

    best_match_id, similarity = find_most_similar(code_embedding, code_embeddings)
    if not best_match_id:
        print("\n類似コードが見つかりません")
        return

    print(f"\n最も類似したコード ID: {best_match_id}")
    print(f"類似度: {similarity:.4f}")

    similar_code = get_code_by_id(best_match_id)
    if not similar_code:
        print(f"\nコード ID {best_match_id} の取得に失敗しました")
        return

    test_cases = get_test_cases(best_match_id)
    if not test_cases:
        print(f"\nコード ID {best_match_id} のテストケースが見つかりません")
        return

    # 全テストケースの表示
    print("\n=== 利用可能なテストケース ===")
    for i, (input_val, expected_output) in enumerate(test_cases, 1):
        print(f"\nテストケース {i}:")
        print(f"入力値: {input_val}")
        print(f"期待される出力: {expected_output}")

    # テストケース実行の確認
    user_input = input("\n上記のテストケースを実行しますか？ (y/n): ").lower()

    if user_input == "y":
        # 全テストケースの実行
        print("\n=== テスト実行開始 ===")
        test_results = []
        for input_val, expected_output in test_cases:
            success, actual = test_runner.run_test_case(
                code, input_val, expected_output
            )
            test_results.append((input_val, expected_output, success, actual))
            print(f"\n入力値: {input_val}")
            print(f"期待される出力: {expected_output}")
            print(f"実際の出力: {actual}")
            print(f"結果: {'✓ Pass' if success else '✗ Fail'}")

        # 結果サマリーの表示
        print(TestResultFormatter.format_test_results(test_results))
    else:
        print("\nテストケースの実行をスキップしました")


def main():
    # データベース初期化
    connection.create_database()
    print("Database created/connected.")

    processor = CodeProcessor()

    # サンプルコードの登録
    # for code_data in code_samples:
    #     processor.process_sample_code(code_data)

    # 類似コード検索のデモ
    print("\n=== 類似コードの検索 ===")
    try:
        with open("question.txt", "r", encoding="utf-8") as f:
            prompt = f.read().strip()
        print(f"プロンプト: {prompt}")

        ai_code = processor.gemini_client.generate_code(prompt)
    except FileNotFoundError:
        print("エラー: question.txtファイルが見つかりません")
        return
    except Exception as e:
        print(f"エラー: プロンプトの読み込み中にエラーが発生しました - {str(e)}")
        return
    if ai_code:
        print(f"\nAI生成コード:\n{ai_code}")
        find_and_test_similar_code(ai_code, TestRunner())
    else:
        print("コードの生成に失敗しました")


if __name__ == "__main__":
    main()

================
File: question.txt
================
Write a function to find the shared elements from the given two lists.

================
File: sample_codes.py
================
"""サンプルコードとテストケースの定義"""

code_samples = [
    {
        "code": """def add(a, b):\n    return a + b""",
        "test_cases": [
            {"input": "1, 2", "expected_output": "3"},
            {"input": "5, -3", "expected_output": "2"},
            {"input": "0, 0", "expected_output": "0"},
            {"input": "-5, -7", "expected_output": "-12"},
            {"input": "100, 200", "expected_output": "300"},
            {"input": "0.5, 0.7", "expected_output": "1.2"},
            {"input": "-1.5, 2.5", "expected_output": "1.0"},
            {"input": "999999, 1", "expected_output": "1000000"},
            {"input": "2.0, -2.0", "expected_output": "0.0"},
            {"input": "1.23456, 2.34567", "expected_output": "3.58023"},
        ],
    },
    {
        "code": """def subtract(a, b):\n    return a - b""",
        "test_cases": [
            {"input": "5, 3", "expected_output": "2"},
            {"input": "10, -5", "expected_output": "15"},
            {"input": "0, 0", "expected_output": "0"},
            {"input": "-5, -3", "expected_output": "-2"},
            {"input": "100, 99", "expected_output": "1"},
            {"input": "1000, 1", "expected_output": "999"},
            {"input": "3.14, 1.14", "expected_output": "2.0"},
            {"input": "1, 2", "expected_output": "-1"},
            {"input": "0.5, 0.25", "expected_output": "0.25"},
            {"input": "10.1, 0.1", "expected_output": "10.0"},
        ],
    },
    {
        "code": """def multiply(a, b):\n    return a * b""",
        "test_cases": [
            {"input": "2, 3", "expected_output": "6"},
            {"input": "5, 0", "expected_output": "0"},
            {"input": "-4, 3", "expected_output": "-12"},
            {"input": "-2, -3", "expected_output": "6"},
            {"input": "0.5, 4", "expected_output": "2.0"},
            {"input": "1.5, 2.5", "expected_output": "3.75"},
            {"input": "10, 10", "expected_output": "100"},
            {"input": "0.1, 0.1", "expected_output": "0.01"},
            {"input": "100, 0.5", "expected_output": "50.0"},
            {"input": "-1, 999", "expected_output": "-999"},
        ],
    },
    {
        "code": """def divide(a, b):\n    return a / b if b != 0 else 'Error: Division by zero'""",
        "test_cases": [
            {"input": "6, 2", "expected_output": "3.0"},
            {"input": "5, 0", "expected_output": "Error: Division by zero"},
            {"input": "-6, 2", "expected_output": "-3.0"},
            {"input": "0, 5", "expected_output": "0.0"},
            {"input": "10, 3", "expected_output": "3.3333333333333335"},
            {"input": "1, 2", "expected_output": "0.5"},
            {"input": "-10, -2", "expected_output": "5.0"},
            {"input": "100, 4", "expected_output": "25.0"},
            {"input": "1, 3", "expected_output": "0.3333333333333333"},
            {"input": "7, 7", "expected_output": "1.0"},
        ],
    },
    {
        "code": """def power(base, exponent):\n    return base ** exponent""",
        "test_cases": [
            {"input": "2, 3", "expected_output": "8"},
            {"input": "5, 0", "expected_output": "1"},
            {"input": "2, -1", "expected_output": "0.5"},
            {"input": "3, 2", "expected_output": "9"},
            {"input": "10, 2", "expected_output": "100"},
            {"input": "2, 10", "expected_output": "1024"},
            {"input": "1, 5", "expected_output": "1"},
            {"input": "-2, 2", "expected_output": "4"},
            {"input": "-2, 3", "expected_output": "-8"},
            {"input": "0.5, 2", "expected_output": "0.25"},
        ],
    },
    {
        "code": """def factorial(n):\n    return 1 if n <= 1 else n * factorial(n-1)""",
        "test_cases": [
            {"input": "0", "expected_output": "1"},
            {"input": "1", "expected_output": "1"},
            {"input": "2", "expected_output": "2"},
            {"input": "3", "expected_output": "6"},
            {"input": "4", "expected_output": "24"},
            {"input": "5", "expected_output": "120"},
            {"input": "6", "expected_output": "720"},
            {"input": "7", "expected_output": "5040"},
            {"input": "8", "expected_output": "40320"},
            {"input": "10", "expected_output": "3628800"},
        ],
    },
    {
        "code": """def is_palindrome(text):\n    text = str(text).lower()\n    return text == text[::-1]""",
        "test_cases": [
            {"input": "'radar'", "expected_output": "True"},
            {"input": "'hello'", "expected_output": "False"},
        ],
    },
    {
        "code": """def fibonacci(n):\n    if n <= 1: return n\n    return fibonacci(n-1) + fibonacci(n-2)""",
        "test_cases": [
            {"input": "0", "expected_output": "0"},
            {"input": "1", "expected_output": "1"},
            {"input": "2", "expected_output": "1"},
            {"input": "7", "expected_output": "13"},
            {"input": "8", "expected_output": "21"},
            {"input": "9", "expected_output": "34"},
        ],
    },
    {
        "code": """def count_vowels(text):\n    return sum(1 for char in text.lower() if char in 'aeiou')""",
        "test_cases": [
            {
                "input": "'hello'",
                "expected_output": "2",
                "description": "Basic word",
            },
            {
                "input": "'AEIOU'",
                "expected_output": "5",
                "description": "All vowels",
            },
            {
                "input": "'rhythm'",
                "expected_output": "0",
                "description": "No vowels",
            },
            {
                "input": "'Python'",
                "expected_output": "1",
                "description": "One vowel",
            },
            {
                "input": "'beautiful'",
                "expected_output": "5",
                "description": "Multiple vowels",
            },
            {
                "input": "'AeIoU'",
                "expected_output": "5",
                "description": "Mixed case vowels",
            },
            {
                "input": "'123'",
                "expected_output": "0",
                "description": "Numbers only",
            },
            {
                "input": "'OpenAI'",
                "expected_output": "4",
                "description": "Company name",
            },
            {
                "input": "'aaa'",
                "expected_output": "3",
                "description": "Repeated vowels",
            },
            {
                "input": "'XYZ'",
                "expected_output": "0",
                "description": "Consonants only",
            },
        ],
    },
    {
        "code": """def reverse_string(text):\n    return text[::-1]""",
        "test_cases": [
            {"input": "'hello'", "expected_output": "'olleh'"},
            {"input": "'radar'", "expected_output": "'radar'"},
            {"input": "'123 456'", "expected_output": "'654 321'"},
            {"input": "'!@#$%'", "expected_output": "'%$#@!'"},
        ],
    },
]

================
File: verify_data.py
================
from typing import Dict, Any
from database.context import db_context


def get_database_stats() -> Dict[str, Any]:
    """データベースの統計情報を取得します。"""
    try:
        with db_context() as (_, cursor):
            # コードの統計
            cursor.execute("""
                SELECT 
                    COUNT(*) as total_codes,
                    SUM(CASE WHEN embedding IS NOT NULL THEN 1 ELSE 0 END) as codes_with_embedding
                FROM codes
            """)
            code_stats = cursor.fetchone()

            # テストケースの統計
            cursor.execute("""
                SELECT 
                    COUNT(*) as total_tests,
                    COUNT(DISTINCT code_id) as codes_with_tests,
                    AVG(LENGTH(input)) as avg_input_length,
                    AVG(LENGTH(expected_output)) as avg_output_length
                FROM test_cases
            """)
            test_stats = cursor.fetchone()

            return {
                "total_codes": code_stats[0],
                "codes_with_embedding": code_stats[1],
                "total_test_cases": test_stats[0],
                "codes_with_tests": test_stats[1],
                "avg_input_length": round(test_stats[2], 2) if test_stats[2] else 0,
                "avg_output_length": round(test_stats[3], 2) if test_stats[3] else 0
            }
    except Exception as e:
        print(f"Error getting database stats: {e}")
        return {}


def get_sample_data() -> Dict[str, Any]:
    """サンプルデータを取得します。"""
    try:
        with db_context() as (_, cursor):
            # 最新のコードサンプル
            cursor.execute("""
                SELECT id, substr(code, 1, 100) as code_preview, 
                       CASE WHEN embedding IS NOT NULL THEN 1 ELSE 0 END as has_embedding
                FROM codes 
                ORDER BY id DESC 
                LIMIT 1
            """)
            code_sample = cursor.fetchone()

            # そのコードのテストケース
            test_cases = []
            if code_sample:
                cursor.execute("""
                    SELECT input, expected_output 
                    FROM test_cases 
                    WHERE code_id = ? 
                    LIMIT 3
                """, (code_sample[0],))
                test_cases = cursor.fetchall()

            return {
                "sample_code": {
                    "id": code_sample[0] if code_sample else None,
                    "preview": code_sample[1] if code_sample else None,
                    "has_embedding": bool(code_sample[2]) if code_sample else False
                },
                "sample_test_cases": test_cases
            }
    except Exception as e:
        print(f"Error getting sample data: {e}")
        return {}


def verify_data():
    """データベースの状態を検証し、結果を表示します。"""
    # 統計情報の取得と表示
    stats = get_database_stats()
    if stats:
        print("\n=== データベース統計 ===")
        print(f"コードの総数: {stats['total_codes']}")
        print(f"埋め込みベクトルを持つコード: {stats['codes_with_embedding']}")
        print(f"テストケースの総数: {stats['total_test_cases']}")
        print(f"テストケースを持つコード: {stats['codes_with_tests']}")
        print(f"平均入力長: {stats['avg_input_length']}")
        print(f"平均出力長: {stats['avg_output_length']}")

    # サンプルデータの取得と表示
    samples = get_sample_data()
    if samples and samples["sample_code"]["id"]:
        print("\n=== 最新のコードサンプル ===")
        print(f"ID: {samples['sample_code']['id']}")
        print(f"コードプレビュー: {samples['sample_code']['preview']}...")
        print(f"埋め込みベクトルの有無: {'あり' if samples['sample_code']['has_embedding'] else 'なし'}")

        if samples["sample_test_cases"]:
            print("\n=== テストケースサンプル ===")
            for i, (input_val, expected_output) in enumerate(samples["sample_test_cases"], 1):
                print(f"\nテストケース {i}:")
                print(f"入力: {input_val}")
                print(f"期待される出力: {expected_output}")


if __name__ == "__main__":
    verify_data()
